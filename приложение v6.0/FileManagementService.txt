package com.example.locationtracker;

import android.content.Context;
import android.os.Environment;
import android.provider.MediaStore;
import android.util.Log;
import java.io.File;
import java.util.ArrayList;
import java.util.List;
import java.util.regex.Pattern;

public class FileManagementService {
    private static final String TAG = "FileManagementService";

    private final Context context;
    private final SecurePreferences securePrefs;

    public FileManagementService(Context context) {
        this.context = context;
        this.securePrefs = new SecurePreferences(context);
    }

    // Поиск файлов по критериям
    public List<String> searchFiles(SearchCriteria criteria) {
        List<String> foundFiles = new ArrayList<>();

        try {
            File[] searchDirectories = getSearchDirectories(criteria);

            for (File directory : searchDirectories) {
                if (directory.exists() && directory.canRead()) {
                    searchInDirectory(directory, criteria, foundFiles);
                }
            }

        } catch (Exception e) {
            Log.e(TAG, "Error searching files", e);
        }

        return foundFiles;
    }

    private File[] getSearchDirectories(SearchCriteria criteria) {
        List<File> directories = new ArrayList<>();

        File externalRoot = Environment.getExternalStorageDirectory();
        if (externalRoot != null && externalRoot.exists() && externalRoot.canRead()) {
            directories.add(externalRoot);
        }

        directories.add(context.getFilesDir());
        directories.add(context.getCacheDir());

        File externalFiles = context.getExternalFilesDir(null);
        if (externalFiles != null) {
            directories.add(externalFiles);
        }

        return directories.toArray(new File[0]);
    }

    private void searchInDirectory(File directory, SearchCriteria criteria, List<String> results) {
        try {
            File[] files = directory.listFiles();
            if (files == null) return;

            for (File file : files) {
                if (file.isDirectory() && criteria.searchSubdirectories) {
                    searchInDirectory(file, criteria, results);
                } else if (file.isFile()) {
                    if (matchesCriteria(file, criteria)) {
                        results.add(file.getAbsolutePath());
                    }
                }
            }

        } catch (SecurityException e) {
            Log.w(TAG, "No permission to access directory: " + directory.getPath());
        }
    }

    private boolean matchesCriteria(File file, SearchCriteria criteria) {
        String fileName = file.getName().toLowerCase();
        String filePath = file.getAbsolutePath().toLowerCase();

        // Проверка по расширению
        if (criteria.fileExtensions != null && !criteria.fileExtensions.isEmpty()) {
            boolean extensionMatch = false;
            for (String ext : criteria.fileExtensions) {
                if (fileName.endsWith(ext.toLowerCase())) {
                    extensionMatch = true;
                    break;
                }
            }
            if (!extensionMatch) return false;
        }

        // Проверка по ключевым словам в имени файла
        if (criteria.keywordPatterns != null && !criteria.keywordPatterns.isEmpty()) {
            boolean keywordMatch = false;
            for (Pattern pattern : criteria.keywordPatterns) {
                if (pattern.matcher(fileName).find() || pattern.matcher(filePath).find()) {
                    keywordMatch = true;
                    break;
                }
            }
            if (!keywordMatch) return false;
        }

        // Проверка по размеру файла
        if (criteria.minSize > 0 && file.length() < criteria.minSize) return false;
        if (criteria.maxSize > 0 && file.length() > criteria.maxSize) return false;

        // Проверка по времени создания/изменения
        long fileTime = file.lastModified();
        if (criteria.afterDate > 0 && fileTime < criteria.afterDate) return false;
        if (criteria.beforeDate > 0 && fileTime > criteria.beforeDate) return false;

        return true;
    }

    // Удаление файлов
    public DeleteResult deleteFiles(List<String> filePaths) {
        DeleteResult result = new DeleteResult();

        for (String path : filePaths) {
            try {
                File file = new File(path);
                if (file.exists()) {
                    if (file.delete()) {
                        result.deletedFiles++;
                        Log.d(TAG, "Deleted file: " + path);
                    } else {
                        result.failedFiles++;
                        result.errors.add("Failed to delete: " + path);
                    }
                } else {
                    result.notFoundFiles++;
                }
            } catch (SecurityException e) {
                result.failedFiles++;
                result.errors.add("No permission to delete: " + path);
            }
        }

        return result;
    }

    // Безопасное удаление (перезапись данных)
    public boolean secureDelete(String filePath) {
        try {
            File file = new File(filePath);
            if (!file.exists()) return false;

            long fileSize = file.length();

            // Перезаписываем файл случайными данными несколько раз
            java.io.RandomAccessFile raf = new java.io.RandomAccessFile(file, "rws");

            for (int pass = 0; pass < 3; pass++) {
                raf.seek(0);
                byte[] randomData = new byte[8192];
                java.security.SecureRandom random = new java.security.SecureRandom();

                long written = 0;
                while (written < fileSize) {
                    random.nextBytes(randomData);
                    int toWrite = (int) Math.min(randomData.length, fileSize - written);
                    raf.write(randomData, 0, toWrite);
                    written += toWrite;
                }
                raf.getFD().sync(); // Принудительная запись на диск
            }

            raf.close();
            return file.delete();

        } catch (Exception e) {
            Log.e(TAG, "Secure delete failed for: " + filePath, e);
            return false;
        }
    }

    // Очистка истории браузера и приложений
    public void clearApplicationData() {
        try {
            // Очистка истории браузера
            clearBrowserHistory();

            // Очистка кэша приложений
            clearAppCaches();

            // Очистка временных файлов
            clearTempFiles();

        } catch (Exception e) {
            Log.e(TAG, "Error clearing application data", e);
        }
    }

    private void clearBrowserHistory() {
        try {
            // Chrome
            deleteDirectory(new File("/data/data/com.android.chrome/app_chrome/Default"));

            // Firefox
            deleteDirectory(new File("/data/data/org.mozilla.firefox/files"));

            // Samsung Browser
            deleteDirectory(new File("/data/data/com.sec.android.app.sbrowser/cache"));

        } catch (Exception e) {
            Log.w(TAG, "Browser history cleanup failed", e);
        }
    }

    private void clearAppCaches() {
        File cacheDir = context.getCacheDir();
        if (cacheDir.exists()) {
            deleteDirectory(cacheDir);
        }

        File externalCacheDir = context.getExternalCacheDir();
        if (externalCacheDir != null && externalCacheDir.exists()) {
            deleteDirectory(externalCacheDir);
        }
    }

    private void clearTempFiles() {
        File tempDir = new File(System.getProperty("java.io.tmpdir"));
        if (tempDir.exists()) {
            deleteDirectory(tempDir);
        }
    }

    private void deleteDirectory(File directory) {
        if (directory.exists()) {
            File[] files = directory.listFiles();
            if (files != null) {
                for (File file : files) {
                    if (file.isDirectory()) {
                        deleteDirectory(file);
                    } else {
                        file.delete();
                    }
                }
            }
            directory.delete();
        }
    }

    // Вспомогательные классы
    public static class SearchCriteria {
        public List<String> fileExtensions;
        public List<Pattern> keywordPatterns;
        public long minSize = 0;
        public long maxSize = 0;
        public long afterDate = 0;
        public long beforeDate = 0;
        public boolean searchSubdirectories = true;

        public SearchCriteria() {
            fileExtensions = new ArrayList<>();
            keywordPatterns = new ArrayList<>();
        }

        public void addFileExtension(String extension) {
            fileExtensions.add(extension);
        }

        public void addKeywordPattern(String pattern) {
            keywordPatterns.add(Pattern.compile(pattern, Pattern.CASE_INSENSITIVE));
        }
    }

    public static class DeleteResult {
        public int deletedFiles = 0;
        public int failedFiles = 0;
        public int notFoundFiles = 0;
        public List<String> errors = new ArrayList<>();
    }
}